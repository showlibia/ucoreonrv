# lab2
## 练习1：如何获取物理内存范围

在 RISC-V 中，这个一般是由 bootloader ，即 OpenSBI 来完成的。它来完成对于包括物理内存在内的各外设的扫描，将扫描结果以 DTB(Device Tree Blob) 的格式保存在物理内存中的某个地方。随后 OpenSBI 会将其地址保存在 a1 寄存器中，给我们使用。

这个扫描结果描述了所有外设的信息，当中也包括 Qemu 模拟的 RISC-V 计算机中的物理内存。

## 练习2：实现Best Fit页面分配算法

best fit的算法思想就是按照内存容量排序，然后物理内存页管理器搜索整个双向链表（从开始到结束），找出能够满足申请分配的空间大小的最小空闲区域。如果空闲区域的大小和申请分配的大小正好一样，则把这个空闲区域分配出去，成功返回；否则将该空闲区分为两部分，一部分区域与申请分配的大小相等，把它分配出去，剩下的一部分区域形成新的空闲区。其释放内存的设计思路很简单，只需把这块区域重新放回双向链表中即可。

### best_fit_init_memmap的实现

* 对提供的内存块进行初始化操作
* 将代表内存块第一个帧的`struct Page`插入合适位置
    * 若链表为空，则直接加入链表
    * 否则从前往后搜索
        * 若链表中当前块`property`更大，则插入到它的前方
        * 若已到链表结尾(表头前的一个`page_link`)，则在该位置插入

按这种方式初始化可以保证内存块按内存块容量大小在链表中顺序排列

### best_fit_alloc_pages的实现

* 若申请空间大于可用总空间，直接返回NULL
* 从表头开始向后搜索，直到再次遇到表头位置
* 对每块内存，检查可用空间
    * 若有可用空间，则从链表中删除这块内存
        * 若可用空间大于申请空间，则从末端切除多余的空间放回链表中原来的位置
    * 若无可用空间，继续搜索下一块内存
* 返回page指针

这种分配方式符合"best fit"的要求

### best_fit_free_pages实现

* 用best_fit_init_memmap中的方式将返还的Page插入链表
* 检查前方的内存块是否可以和该内存块合并，若能则进行合并，并将指针指向合并后的Page
* 检查后方的内存块是否可以和该内存块合并，若能则进行合并

注意插入后最多是三块内存合并，若有超过三块内存需要合并，说明之前有连续的内存块未进行合并，在正确
初始化后这是不可能发生的

### 改进空间

内存块可以改用线段树管理，这样可以保证在log(n)时间内找到满足要求的空闲内存块