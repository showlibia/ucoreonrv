## 练习一：在 FIFO 页面置换算法下，一个页面从被换入到被换出的过程中，会经过多个函数/宏的处理。以下是关键函数的执行流程，并简要描述每个函数的作用：

***find_vma():***

查找地址对应的虚拟内存区域（VMA）。如果地址没有对应的 VMA，会返回 NULL，处理无效的虚拟地址。

***get_pte():***

获取虚拟地址对应的页表项（PTE），如果 PTE 不存在并且允许分配新页表项（通过第三个参数控制），则创建新的页表项。
作用：确保虚拟地址有对应的 PTE，为后续页面换入做准备。

***pgfault_handler():***

处理缺页异常（Page Fault）。当访问的虚拟地址没有对应的物理页时，该函数被调用。
作用：负责启动页面换入流程，从磁盘或交换区加载页面到物理内存。

***swap_in():***

负责将页面从磁盘或交换区加载到内存。该函数首先通过 alloc_page() 分配一个新的物理页面，然后将页面数据从磁盘读入该物理页面。
作用：将页面换入内存，并准备好映射。

***alloc_page():***

分配一个新的物理页面。页面换入时必须先分配物理内存。
作用：从物理内存中分配一个空闲页框。

***swapfs_read():***

将页面数据从交换区或磁盘读取到分配的物理页面中。
作用：负责真正的页面数据加载。

***page_insert():***

将页面插入到页表中，建立虚拟地址与物理页面的映射。
作用：更新页表项，使虚拟地址指向正确的物理页面。

***tlb_invalidate():***

刷新 TLB（Translation Lookaside Buffer），确保旧的页面映射被清除，使新的映射生效。
作用：刷新地址翻译缓存，使新的页面映射生效。

***_fifo_map_swappable():***

根据 FIFO 算法，将换入的页面链接到页表管理的数据结构（即 FIFO 队列）。
作用：记录页面的换入顺序，方便后续页面置换时选择最早的页面。

***swap_out():***

启动页面换出流程。它调用页面置换算法，选择一个页面作为受害者，并通过 swapfs_write() 将该页面写入磁盘。
作用：选择页面进行换出，并将其从物理内存中移除。

***_fifo_swap_out_victim():***

根据 FIFO 算法，选择最早被换入的页面作为受害者。
作用：选择要被换出的页面。

***swapfs_write():***

将要换出的页面写入交换区或磁盘。
作用：将页面从物理内存中保存到磁盘。

***page_remove():***

从页表中移除页面的映射关系，并释放该页面对应的物理内存。
作用：将虚拟地址与物理页面的映射取消，页面被换出。

***free_page():***

释放换出页面的物理内存，将其归还到空闲页列表中。
作用：回收被换出的物理内存。


## 练习二：理解get_pte函数 
###  get_pte()函数中有两段形式类似的代码， 结合sv32，sv39，sv48的异同，解释这两段代码为什么如此相像?


***页表结构：***

SV32：使用两个层级的页表。虚拟地址由 32 位组成，分为 10 位索引（第一级）和 10 位索引（第二级）和 12 位页内偏移（offset）。
SV39：使用三个层级的页表。虚拟地址由 39 位组成，分为 9 位索引（第一级）、9 位索引（第二级）和 9 位索引（第三级）以及 12 位页内偏移。
SV48：使用四个层级的页表。虚拟地址由 48 位组成，分为 9 位索引（第一级）、9 位索引（第二级）、9 位索引（第三级）和 9 位索引（第四级）以及 12 位页内偏移。

***页表项格式：***

各种格式的页表项结构相似，但根据地址空间的不同，其字段的宽度和用途可能有所不同。
它们都包含有效位、物理页号、权限位等。

因此我们看到，对于不同的分页标准，对于页表的查询都是 页地址+第n级索引——>下一级页表项
在 get_pte() 函数中，无论是 SV32、SV39 还是 SV48，虚拟地址都需要地址分解：分解为对应的索引（indexes）和页内偏移（offset）。在查找页表项时，都会通过页表索引来访问具体的页表项，检查对应级别的页表是否存在。
```c
pde_t *pdep1 = &pgdir[PDX1(la)];//通过页表索引来访问具体的页表项
if (!(*pdep1 & PTE_V))//检查对应级别的页表是否有效
{/*创建页表项 */}


pde_t *pdep0 = &((pde_t *)KADDR(PDE_ADDR(*pdep1)))[PDX0(la)];//通过页表索引来访问具体的页表项
if (!(*pdep0 & PTE_V))//检查对应级别的页表是否有效 
{/*创建页表项 */}
```
这两段代码的结构相似是由于它们在处理虚拟地址时遵循相同的基本逻辑，尽管具体的索引位数和页表层级不同。

### 目前get_pte()函数将页表项的查找和页表项的分配合并在一个函数里，你认为这种写法好吗？有没有必要把两个功能拆开？
我觉得有必要拆开，在目前的get_pte()函数中，只要判断页表项无效
```c
if (!(*pdep1 & PTE_V))
```
之后，就会立刻进行申请页、分配页表项，但是页表项的***valid***位无效的原因有很多种，例如

***1. 虚拟地址尚未映射***
当一个虚拟地址从未分配过物理页时，页表项的 Valid 标志为 0。

***2. 页被换出到硬盘（Swap Out）***
当操作系统使用了 页面置换（Paging/Swapping）机制时，如果物理内存不足，某些不常使用的页面可能会被换出到硬盘（交换区）。这时，虽然页表项仍然保留着该虚拟地址的信息，但因为物理内存中的实际数据已被换出，因此 Valid 标志会被置为 0，标识该页不再在内存中。

例子: 在 swap_out() 过程中，如果某个页面被选择为置换的受害者，它会被写入交换区，页表项会保留虚拟地址，但 Valid 置为 0。访问这些地址时会触发页错误，随后操作系统会调用 swap_in() 重新从磁盘加载该页。

***3. 程序试图访问不合法的虚拟地址***
如果程序试图访问没有权限的虚拟地址（例如访问一个已经释放的地址，或者访问不属于程序的地址），这类地址可能也会触发页错误，因为对应的页表项的 Valid 标志为 0。

因此，valid位为0之后不一定就要立即进行分配操作，如果地址是合法的，但页表项无效，操作系统可能会为其分配一个物理内存页，并将 Valid 标志置为 1。如果是由于页被换出到磁盘而导致 Valid 为 0，操作系统会从磁盘（交换区或文件系统）重新加载该页。

## 练习三：实现Clock页替换算法
相比于fifo算法，clock算法维护一项page组成的循环链表以及一项page结构体字段：visited，访问该物理页后visited为1，在clock轮转之后，visited为1的置为0，第一个访问到的visited为0的作为“受害者”换出内存，具体代码如下：

```c
static int
_clock_init_mm(struct mm_struct *mm)
{   
     list_init(&pra_list_head);
     mm->sm_priv = &pra_list_head;
     curr_ptr = &pra_list_head;
     //cprintf(" mm->sm_priv %x in fifo_init_mm\n",mm->sm_priv);
     return 0;
}


static int
_clock_map_swappable(struct mm_struct *mm, uintptr_t addr, struct Page *page, int swap_in)
{
    list_entry_t *head = (list_entry_t*) mm->sm_priv;
    list_entry_t *entry = &(page->pra_page_link);

    assert(entry != NULL && head != NULL);

    list_add_before(head, entry);
    page->visited = 1;
    return 0;
}


static int
_clock_swap_out_victim(struct mm_struct *mm, struct Page ** ptr_page, int in_tick)
{
     list_entry_t *head = (list_entry_t*) mm->sm_priv;
    assert(head != NULL);
    assert(in_tick == 0);

    while (1) {
        curr_ptr = list_next(curr_ptr);  // 移动时钟指针

        // 如果时钟指针回到了链表头，则继续下一个
        if (curr_ptr == head) {
            continue;
        }

        // 获取时钟指针指向的页面
        struct Page *page = le2page(curr_ptr, pra_page_link);

        if (page->visited == 1) {
            // 如果页面的使用位为 1，清除使用位，并移动指针
            page->visited = 0;
        } else {
            // 如果页面的使用位为 0，选择该页面换出
            list_del(curr_ptr);  // 从链表中移除该页面
            *ptr_page = page;  // 设置为要换出的页面
            return 0;  // 返回，表示已经选择了一个换出的页面
        }
    }
    return -1;  // 失败
}
```